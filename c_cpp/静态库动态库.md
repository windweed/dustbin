# 静态库动态库

本质上来说，库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。

静态库动态库的区别来自于**链接阶段**如何处理库。编译时是不分的。

## 静态库

在链接阶段，会将汇编生成的目标文件`.o`与引用到的库一起链接打包到可执行文件中。\
其实一个静态库可以简单看成是**一组目标文件(.o)的集合**，即很多目标文件经过压缩打包后形成的一个文件。\
静态库特点：

*   静态库对函数的链接是放在编译时期完成的。
*   程序在运行时与函数库再无瓜葛，移植方便。
*   浪费空间和资源，因为所有相关的目标文件与涉及到的函数库被链接成一个文件。

### 创建静态库

使用`ar`工具将目标文件压缩到一起，并且对其进行编号和索引，以便查找和检索。\
即工作流为：

1.  `$ g++ -c StaticMatch.cpp`编译出.o文件。(生成了StaticMath.o)
2.  `$ ar -crv libstaticmath.a StaticMath.o`
    当然，现在一般使用CMake来生成静态库。

### 使用静态库

只需要在编译的时候，指定静态库的搜索路径(-L)，指定静态库名(-l)。\
`$ g++ TestStaticLibrary.cpp -L. -lstaticmath`\
这也说明，静态库是编译时连进去的。

***

**为什么需要动态库？**

*   空间浪费。 静态库在内存中存在多份拷贝导致空间浪费。假如静态库占用1M内存，有2000个这样的程序，将占用近2G空间。
*   更新麻烦。如果某库更新了，所有使用这个库的代码都要重新编译。

***

动态库在编译的时候并不会被链接到目标代码中，而是在程序运行时才被载入。\
不同的应用程序如果调用相同的库，那么在内存中只需要一份该动态库的实例，避免了空间浪费。\
同时，由于是运行时才被载入，所以更新时用户只需要更新动态库即可。

***

动态库特点总结

*   可以实现进程间的资源共享
*   甚至可以真正做到链接载入完全由程序员在程序代码中控制(显式调用)
*   与创建静态库不同的是，不需要打包工具(ar)，直接使用编译器即可创建动态库。

### 创建动态库

*   `$ g++ -fPIC -c DynamicMath.cpp` (Position Independent Code)
*   `$ g++ -shared -o libdynmath.so DyNamicMath.o`
*   注意设置`LD_LIBRARY_PATH`

